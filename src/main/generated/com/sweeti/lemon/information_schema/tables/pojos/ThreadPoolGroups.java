/*
 * This file is generated by jOOQ.
 */
package com.sweeti.lemon.information_schema.tables.pojos;


import java.io.Serializable;


/**
 * This class is generated by jOOQ.
 */
@SuppressWarnings({ "all", "unchecked", "rawtypes" })
public class ThreadPoolGroups implements Serializable {

    private static final long serialVersionUID = 1L;

    private final Integer groupId;
    private final Integer connections;
    private final Integer threads;
    private final Integer activeThreads;
    private final Integer standbyThreads;
    private final Integer queueLength;
    private final Byte hasListener;
    private final Byte isStalled;

    public ThreadPoolGroups(ThreadPoolGroups value) {
        this.groupId = value.groupId;
        this.connections = value.connections;
        this.threads = value.threads;
        this.activeThreads = value.activeThreads;
        this.standbyThreads = value.standbyThreads;
        this.queueLength = value.queueLength;
        this.hasListener = value.hasListener;
        this.isStalled = value.isStalled;
    }

    public ThreadPoolGroups(
        Integer groupId,
        Integer connections,
        Integer threads,
        Integer activeThreads,
        Integer standbyThreads,
        Integer queueLength,
        Byte hasListener,
        Byte isStalled
    ) {
        this.groupId = groupId;
        this.connections = connections;
        this.threads = threads;
        this.activeThreads = activeThreads;
        this.standbyThreads = standbyThreads;
        this.queueLength = queueLength;
        this.hasListener = hasListener;
        this.isStalled = isStalled;
    }

    /**
     * Getter for <code>information_schema.THREAD_POOL_GROUPS.GROUP_ID</code>.
     */
    public Integer getGroupId() {
        return this.groupId;
    }

    /**
     * Getter for
     * <code>information_schema.THREAD_POOL_GROUPS.CONNECTIONS</code>.
     */
    public Integer getConnections() {
        return this.connections;
    }

    /**
     * Getter for <code>information_schema.THREAD_POOL_GROUPS.THREADS</code>.
     */
    public Integer getThreads() {
        return this.threads;
    }

    /**
     * Getter for
     * <code>information_schema.THREAD_POOL_GROUPS.ACTIVE_THREADS</code>.
     */
    public Integer getActiveThreads() {
        return this.activeThreads;
    }

    /**
     * Getter for
     * <code>information_schema.THREAD_POOL_GROUPS.STANDBY_THREADS</code>.
     */
    public Integer getStandbyThreads() {
        return this.standbyThreads;
    }

    /**
     * Getter for
     * <code>information_schema.THREAD_POOL_GROUPS.QUEUE_LENGTH</code>.
     */
    public Integer getQueueLength() {
        return this.queueLength;
    }

    /**
     * Getter for
     * <code>information_schema.THREAD_POOL_GROUPS.HAS_LISTENER</code>.
     */
    public Byte getHasListener() {
        return this.hasListener;
    }

    /**
     * Getter for <code>information_schema.THREAD_POOL_GROUPS.IS_STALLED</code>.
     */
    public Byte getIsStalled() {
        return this.isStalled;
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj)
            return true;
        if (obj == null)
            return false;
        if (getClass() != obj.getClass())
            return false;
        final ThreadPoolGroups other = (ThreadPoolGroups) obj;
        if (this.groupId == null) {
            if (other.groupId != null)
                return false;
        }
        else if (!this.groupId.equals(other.groupId))
            return false;
        if (this.connections == null) {
            if (other.connections != null)
                return false;
        }
        else if (!this.connections.equals(other.connections))
            return false;
        if (this.threads == null) {
            if (other.threads != null)
                return false;
        }
        else if (!this.threads.equals(other.threads))
            return false;
        if (this.activeThreads == null) {
            if (other.activeThreads != null)
                return false;
        }
        else if (!this.activeThreads.equals(other.activeThreads))
            return false;
        if (this.standbyThreads == null) {
            if (other.standbyThreads != null)
                return false;
        }
        else if (!this.standbyThreads.equals(other.standbyThreads))
            return false;
        if (this.queueLength == null) {
            if (other.queueLength != null)
                return false;
        }
        else if (!this.queueLength.equals(other.queueLength))
            return false;
        if (this.hasListener == null) {
            if (other.hasListener != null)
                return false;
        }
        else if (!this.hasListener.equals(other.hasListener))
            return false;
        if (this.isStalled == null) {
            if (other.isStalled != null)
                return false;
        }
        else if (!this.isStalled.equals(other.isStalled))
            return false;
        return true;
    }

    @Override
    public int hashCode() {
        final int prime = 31;
        int result = 1;
        result = prime * result + ((this.groupId == null) ? 0 : this.groupId.hashCode());
        result = prime * result + ((this.connections == null) ? 0 : this.connections.hashCode());
        result = prime * result + ((this.threads == null) ? 0 : this.threads.hashCode());
        result = prime * result + ((this.activeThreads == null) ? 0 : this.activeThreads.hashCode());
        result = prime * result + ((this.standbyThreads == null) ? 0 : this.standbyThreads.hashCode());
        result = prime * result + ((this.queueLength == null) ? 0 : this.queueLength.hashCode());
        result = prime * result + ((this.hasListener == null) ? 0 : this.hasListener.hashCode());
        result = prime * result + ((this.isStalled == null) ? 0 : this.isStalled.hashCode());
        return result;
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder("ThreadPoolGroups (");

        sb.append(groupId);
        sb.append(", ").append(connections);
        sb.append(", ").append(threads);
        sb.append(", ").append(activeThreads);
        sb.append(", ").append(standbyThreads);
        sb.append(", ").append(queueLength);
        sb.append(", ").append(hasListener);
        sb.append(", ").append(isStalled);

        sb.append(")");
        return sb.toString();
    }
}
