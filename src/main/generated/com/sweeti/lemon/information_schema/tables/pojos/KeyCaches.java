/*
 * This file is generated by jOOQ.
 */
package com.sweeti.lemon.information_schema.tables.pojos;


import java.io.Serializable;

import org.jooq.types.UInteger;
import org.jooq.types.ULong;


/**
 * This class is generated by jOOQ.
 */
@SuppressWarnings({ "all", "unchecked", "rawtypes" })
public class KeyCaches implements Serializable {

    private static final long serialVersionUID = 1L;

    private final String keyCacheName;
    private final UInteger segments;
    private final UInteger segmentNumber;
    private final ULong fullSize;
    private final ULong blockSize;
    private final ULong usedBlocks;
    private final ULong unusedBlocks;
    private final ULong dirtyBlocks;
    private final ULong readRequests;
    private final ULong reads;
    private final ULong writeRequests;
    private final ULong writes;

    public KeyCaches(KeyCaches value) {
        this.keyCacheName = value.keyCacheName;
        this.segments = value.segments;
        this.segmentNumber = value.segmentNumber;
        this.fullSize = value.fullSize;
        this.blockSize = value.blockSize;
        this.usedBlocks = value.usedBlocks;
        this.unusedBlocks = value.unusedBlocks;
        this.dirtyBlocks = value.dirtyBlocks;
        this.readRequests = value.readRequests;
        this.reads = value.reads;
        this.writeRequests = value.writeRequests;
        this.writes = value.writes;
    }

    public KeyCaches(
        String keyCacheName,
        UInteger segments,
        UInteger segmentNumber,
        ULong fullSize,
        ULong blockSize,
        ULong usedBlocks,
        ULong unusedBlocks,
        ULong dirtyBlocks,
        ULong readRequests,
        ULong reads,
        ULong writeRequests,
        ULong writes
    ) {
        this.keyCacheName = keyCacheName;
        this.segments = segments;
        this.segmentNumber = segmentNumber;
        this.fullSize = fullSize;
        this.blockSize = blockSize;
        this.usedBlocks = usedBlocks;
        this.unusedBlocks = unusedBlocks;
        this.dirtyBlocks = dirtyBlocks;
        this.readRequests = readRequests;
        this.reads = reads;
        this.writeRequests = writeRequests;
        this.writes = writes;
    }

    /**
     * Getter for <code>information_schema.KEY_CACHES.KEY_CACHE_NAME</code>.
     */
    public String getKeyCacheName() {
        return this.keyCacheName;
    }

    /**
     * Getter for <code>information_schema.KEY_CACHES.SEGMENTS</code>.
     */
    public UInteger getSegments() {
        return this.segments;
    }

    /**
     * Getter for <code>information_schema.KEY_CACHES.SEGMENT_NUMBER</code>.
     */
    public UInteger getSegmentNumber() {
        return this.segmentNumber;
    }

    /**
     * Getter for <code>information_schema.KEY_CACHES.FULL_SIZE</code>.
     */
    public ULong getFullSize() {
        return this.fullSize;
    }

    /**
     * Getter for <code>information_schema.KEY_CACHES.BLOCK_SIZE</code>.
     */
    public ULong getBlockSize() {
        return this.blockSize;
    }

    /**
     * Getter for <code>information_schema.KEY_CACHES.USED_BLOCKS</code>.
     */
    public ULong getUsedBlocks() {
        return this.usedBlocks;
    }

    /**
     * Getter for <code>information_schema.KEY_CACHES.UNUSED_BLOCKS</code>.
     */
    public ULong getUnusedBlocks() {
        return this.unusedBlocks;
    }

    /**
     * Getter for <code>information_schema.KEY_CACHES.DIRTY_BLOCKS</code>.
     */
    public ULong getDirtyBlocks() {
        return this.dirtyBlocks;
    }

    /**
     * Getter for <code>information_schema.KEY_CACHES.READ_REQUESTS</code>.
     */
    public ULong getReadRequests() {
        return this.readRequests;
    }

    /**
     * Getter for <code>information_schema.KEY_CACHES.READS</code>.
     */
    public ULong getReads() {
        return this.reads;
    }

    /**
     * Getter for <code>information_schema.KEY_CACHES.WRITE_REQUESTS</code>.
     */
    public ULong getWriteRequests() {
        return this.writeRequests;
    }

    /**
     * Getter for <code>information_schema.KEY_CACHES.WRITES</code>.
     */
    public ULong getWrites() {
        return this.writes;
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj)
            return true;
        if (obj == null)
            return false;
        if (getClass() != obj.getClass())
            return false;
        final KeyCaches other = (KeyCaches) obj;
        if (this.keyCacheName == null) {
            if (other.keyCacheName != null)
                return false;
        }
        else if (!this.keyCacheName.equals(other.keyCacheName))
            return false;
        if (this.segments == null) {
            if (other.segments != null)
                return false;
        }
        else if (!this.segments.equals(other.segments))
            return false;
        if (this.segmentNumber == null) {
            if (other.segmentNumber != null)
                return false;
        }
        else if (!this.segmentNumber.equals(other.segmentNumber))
            return false;
        if (this.fullSize == null) {
            if (other.fullSize != null)
                return false;
        }
        else if (!this.fullSize.equals(other.fullSize))
            return false;
        if (this.blockSize == null) {
            if (other.blockSize != null)
                return false;
        }
        else if (!this.blockSize.equals(other.blockSize))
            return false;
        if (this.usedBlocks == null) {
            if (other.usedBlocks != null)
                return false;
        }
        else if (!this.usedBlocks.equals(other.usedBlocks))
            return false;
        if (this.unusedBlocks == null) {
            if (other.unusedBlocks != null)
                return false;
        }
        else if (!this.unusedBlocks.equals(other.unusedBlocks))
            return false;
        if (this.dirtyBlocks == null) {
            if (other.dirtyBlocks != null)
                return false;
        }
        else if (!this.dirtyBlocks.equals(other.dirtyBlocks))
            return false;
        if (this.readRequests == null) {
            if (other.readRequests != null)
                return false;
        }
        else if (!this.readRequests.equals(other.readRequests))
            return false;
        if (this.reads == null) {
            if (other.reads != null)
                return false;
        }
        else if (!this.reads.equals(other.reads))
            return false;
        if (this.writeRequests == null) {
            if (other.writeRequests != null)
                return false;
        }
        else if (!this.writeRequests.equals(other.writeRequests))
            return false;
        if (this.writes == null) {
            if (other.writes != null)
                return false;
        }
        else if (!this.writes.equals(other.writes))
            return false;
        return true;
    }

    @Override
    public int hashCode() {
        final int prime = 31;
        int result = 1;
        result = prime * result + ((this.keyCacheName == null) ? 0 : this.keyCacheName.hashCode());
        result = prime * result + ((this.segments == null) ? 0 : this.segments.hashCode());
        result = prime * result + ((this.segmentNumber == null) ? 0 : this.segmentNumber.hashCode());
        result = prime * result + ((this.fullSize == null) ? 0 : this.fullSize.hashCode());
        result = prime * result + ((this.blockSize == null) ? 0 : this.blockSize.hashCode());
        result = prime * result + ((this.usedBlocks == null) ? 0 : this.usedBlocks.hashCode());
        result = prime * result + ((this.unusedBlocks == null) ? 0 : this.unusedBlocks.hashCode());
        result = prime * result + ((this.dirtyBlocks == null) ? 0 : this.dirtyBlocks.hashCode());
        result = prime * result + ((this.readRequests == null) ? 0 : this.readRequests.hashCode());
        result = prime * result + ((this.reads == null) ? 0 : this.reads.hashCode());
        result = prime * result + ((this.writeRequests == null) ? 0 : this.writeRequests.hashCode());
        result = prime * result + ((this.writes == null) ? 0 : this.writes.hashCode());
        return result;
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder("KeyCaches (");

        sb.append(keyCacheName);
        sb.append(", ").append(segments);
        sb.append(", ").append(segmentNumber);
        sb.append(", ").append(fullSize);
        sb.append(", ").append(blockSize);
        sb.append(", ").append(usedBlocks);
        sb.append(", ").append(unusedBlocks);
        sb.append(", ").append(dirtyBlocks);
        sb.append(", ").append(readRequests);
        sb.append(", ").append(reads);
        sb.append(", ").append(writeRequests);
        sb.append(", ").append(writes);

        sb.append(")");
        return sb.toString();
    }
}
